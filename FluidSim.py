import numpy as np
import polyscope as ps
from tqdm import tqdm
from numba import jit

'''
Dq/Dt = 0 (advection)
du/dt = g (body forces)
du/dt + 1/rho * ∇P = 0 s.t. ∇·u = 0 (pressure/incompressibility)

algorithm:
Start with an initial divergence free velocity field u_0
For time step n = 0, 1, 2, ...
Determine a good time step dt to go from t_n to t_(n+1)
set u_A = advect(u_n, dt, u_n) // advection
add u_B = u_A + dt * g // body forces
set u_(n+1) = project(dt, u_B) // incompressibility

D/Dt = material derivative
D/Dt = d/dt + u d/dx + v d/dy
dq/dx = (q[i+1/2] - q[i-1/2]) / (dx)
'''


@jit(nopython=True)
def bilerp(field, x, y, dx, dy, x_off=0.0, y_off=0.0):
  x_f = (x + x_off) / dx
  y_f = (y + y_off) / dy

  i = int(np.floor(x_f))
  j = int(np.floor(y_f))

  a = x_f - i
  b = y_f - j
  nx, ny = field.shape

  i0 = max(0, min(i, nx - 1))
  j0 = max(0, min(j, ny - 1))
  i1 = max(0, min(i + 1, nx - 1))
  j1 = max(0, min(j + 1, ny - 1))

  v00 = field[i0, j0]
  v10 = field[i1, j0]
  v01 = field[i0, j1]
  v11 = field[i1, j1]

  return ((1 - a) * (1 - b) * v00 +
          a * (1 - b) * v10 +
          (1 - a) * b * v01 +
          a * b * v11)


class FluidSim:
  def __init__(self, N: int, width: float, height: float):
    self.N = N

    # MAC Grid

    '''
    -----v01----
     |         |
    u00  P00  u10
     |         |
    -----v00----
    '''
    self.u = np.zeros((N + 1, N))
    self.v = np.zeros((N, N + 1))
    self.p = np.zeros((N, N))

    self.u_prev = np.zeros((N + 1, N))
    self.v_prev = np.zeros((N, N + 1))

    self.dx = width / N
    self.dy = height / N
    self.dt = 1.0 / 60
    self.t = 0.0

    self.log = dict()
    self.log[self.t] = f'{self.u=}\n{self.u_prev=}\n{self.v=}\n{self.v_prev=}'

  def swap(self):
    self.u, self.u_prev = self.u_prev, self.u
    self.v, self.v_prev = self.v_prev, self.v

  def get_u(self, i, j):
    return (self.u[i, j] + self.u[i+1, j]) * 0.5

  def get_v(self, i, j):
    return (self.v[i, j] + self.v[i, j+1]) * 0.5

  '''
  Chapter 3.
  Advection equation: Dq/Dt = 0
  => q_(n+1) = advect(u, dt, q_n)

  Forward Euler.
  (q[i]_(n+1) - q[i]_n) / dt + u * (q[i+1]_n - q[i-1]_n) / (2 * dx) +
  v * (q[i+1]_n - q[i-1]_n) / (2 * dy) = 0
  But, this is unconditionally unstable no matter how small dt is!
  reason: eigenvalues of the Jacobian generated by the central difference
  are pure imaginary, thus always outside the region of stability.

  solution? semi lagrangian approach.
  which is unconditionally stable. no matter how large dt is!
  q[G]_(n+1) = interpolate(q_n, x[G] - dt * u[G])
  x[P] = x[i] - dt * u[i]
  let x[P] lies in (x[j], x[j+1])
  let a = (x[P] - x[j]) / dx
  q[i]_(n+1) = (1 - a) * q[j]_n + a * q[j+1]_n
  '''

  def advect_u(self):
    dx = self.dx
    dy = self.dy
    dt = self.dt
    N = self.N

    for i in range(N + 1):
      for j in range(N):
        x_i = dx * i
        y_i = dy * (j + 0.5)

        u_here = bilerp(self.u_prev, x_i, y_i, dx, dy)
        v_here = bilerp(self.v_prev, x_i, y_i, dx, dy, x_off=-0.5 * dx)

        x_P = x_i - dt * u_here
        y_P = y_i - dt * v_here

        self.u[i, j] = bilerp(self.u_prev, x_P, y_P, dx, dy, y_off=-0.5 * dy)

  def advect_v(self):
    dx = self.dx
    dy = self.dy
    dt = self.dt
    N = self.N

    for i in range(N):
      for j in range(N + 1):
        x_i = dx * (i + 0.5)
        y_i = dy * j

        u_here = bilerp(self.u_prev, x_i, y_i, dx, dy, y_off=-0.5 * dy)
        v_here = bilerp(self.v_prev, x_i, y_i, dx, dy)

        x_P = x_i - dt * u_here
        y_P = y_i - dt * v_here

        self.v[i, j] = bilerp(self.v_prev, x_P, y_P, dx, dy, x_off=-0.5 * dx)

  def dampen(self, factor=0.8):
    u = self.u
    v = self.v

    u *= factor
    v *= factor

  def project(self, dt):
    pass

  def add_force(self, row_idx, col_idx, fx, fy, radius=3):
    radius_sq = radius**2
    for i in range(max(0, row_idx - radius), min(self.N + 1, row_idx + radius + 1)):
      for j in range(max(0, col_idx - radius), min(self.N + 1, col_idx + radius + 1)):
        dist_sq = (i - row_idx)**2 + (j - col_idx)**2

        if dist_sq < radius_sq:
          strength = 1 - np.sqrt(dist_sq) / radius

          if i < self.u.shape[0] and j < self.u.shape[1]:
            self.u[i][j] += fx * strength * self.dt

          if i < self.v.shape[0] and j < self.v.shape[1]:
            self.v[i][j] += fy * strength * self.dt

  def dump_log(self):
    with open('log.txt', 'w') as f:
      for key, value in self.log.items():
        f.write(f'{key}:\n{value}\n')
