import numpy as np
import polyscope as ps
from tqdm import tqdm

'''
Dq/Dt = 0 (advection)
du/dt = g (body forces)
du/dt + 1/rho * ∇P = 0 s.t. ∇·u = 0 (pressure/incompressibility)

algorithm:
Start with an initial divergence free velocity field u_0
For time step n = 0, 1, 2, ...
Determine a good time step dt to go from t_n to t_(n+1)
set u_A = advect(u_n, dt, u_n) // advection
add u_B = u_A + dt * g // body forces
set u_(n+1) = project(dt, u_B) // incompressibility

D/Dt = material derivative
D/Dt = d/dt + u d/dx + v d/dy
dq/dx = (q[i+1/2] - q[i-1/2]) / (dx)
'''

class FluidSim:
  def __init__(self, N: int, width: int, height: int):
    self.N = N
    self.u = np.zeros((N, N))
    self.v = np.zeros((N, N))
    # self.w = np.zeros((N, N, N))
    self.u_prev = np.zeros((N, N))
    self.v_prev = np.zeros((N, N))
    # self.w_prev = np.zeros((N, N, N))


    # randomize
    # self.u = np.random.uniform(-0.5, 0.5, size=(N, N))
    # self.v = np.random.uniform(-0.5, 0.5, size=(N, N))


    self.dx = width / N
    self.dy = height / N
    self.dt = 1.0 / 60
    self.t = 0.0

    self.log = dict()
    self.log[self.t] = f'{self.u=}\n{self.u_prev=}\n{self.v=}\n{self.v_prev=}'


  def swap(self):
    self.u, self.u_prev = self.u_prev, self.u
    self.v, self.v_prev = self.v_prev, self.v

  '''
  Chapter 3.
  Advection equation: Dq/Dt = 0
  => q_(n+1) = advect(u, dt, q_n)

  Forward Euler.
  (q[i]_(n+1) - q[i]_n) / dt + u * (q[i+1]_n - q[i-1]_n) / (2 * dx) +
  v * (q[i+1]_n - q[i-1]_n) / (2 * dy) = 0
  But, this is unconditionally unstable no matter how small dt is!
  reason: eigenvalues of the Jacobian generated by the central difference
  are pure imaginary, thus always outside the region of stability.

  solution? semi lagrangian approach.
  which is unconditionally stable. no matter how large dt is!
  q[G]_(n+1) = interpolate(q_n, x[G] - dt * u[G])
  x[P] = x[i] - dt * u[i]
  let x[P] lies in (x[j], x[j+1])
  let a = (x[P] - x[j]) / dx
  q[i]_(n+1) = (1 - a) * q[j]_n + a * q[j+1]_n
  '''

  def advect(self, dt, q, q_prev):
    u = self.u
    v = self.v
  
    dx = self.dx
    dy = self.dy
    N = self.N
    
    for i in range(N):
      for j in range(N):
        x_i = dx * i
        y_i = dy * j
        
        x_P = x_i - dt * u[i][j]
        y_P = y_i - dt * v[i][j]
        
        k = int(np.floor(x_P / dx))
        l = int(np.floor(y_P / dy))
        
        k = max(0, min(k, self.N-2))
        l = max(0, min(l, self.N-2))    
        
        x_k = dx * k
        y_l = dy * l
        
        a = (x_P - x_k) / dx
        b = (y_P - y_l) / dy
        
        q[i][j] = ((1 - a) * (1 - b) * q_prev[k][l] + 
                       a * (1 - b) * q_prev[k+1][l] + 
                       (1 - a) * b * q_prev[k][l+1] + 
                       a * b * q_prev[k+1][l+1])

    self.t += dt
    self.log[self.t] = f'{self.u=}\n{self.u_prev=}\n{self.v=}\n{self.v_prev=}'

  def add_force(self, x, y, fx, fy, radius=3):
    for i in range(max(0, x-radius), min(self.N, x+radius+1)):
      for j in range(max(0, y-radius), min(self.N, y+radius+1)):
        dist = np.sqrt((i-x)**2 + (j-y)**2)
        if dist <= radius:
          strength = max(0, 1 - dist/radius)
          self.u[i][j] += fx * strength * self.dt
          self.v[i][j] += fy * strength * self.dt

  def dump_log(self):
    with open('log.txt', 'w') as f:
      for key, value in self.log.items():
        f.write(f'{key}:\n{value}\n')
