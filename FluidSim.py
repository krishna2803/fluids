import numpy as np
import polyscope as ps
from tqdm import tqdm
from numba import jit
import scipy as sp
from scipy.sparse import csr_matrix
from scipy.sparse.linalg import cg
from scipy.sparse.linalg import spilu
from scipy.sparse.linalg import LinearOperator

'''
Dq/Dt = 0 (advection)
du/dt = g (body forces)
du/dt + 1/rho * ∇P = 0 s.t. ∇·u = 0 (pressure/incompressibility)

algorithm:
Start with an initial divergence free velocity field u_0
For time step n = 0, 1, 2, ...
Determine a good time step dt to go from t_n to t_(n+1)
set u_A = advect(u_n, dt, u_n) // advection
add u_B = u_A + dt * g // body forces
set u_(n+1) = project(dt, u_B) // incompressibility

D/Dt = material derivative
D/Dt = d/dt + u d/dx + v d/dy
dq/dx = (q[i+1/2] - q[i-1/2]) / (dx)
'''


@jit(nopython=True)
def bilerp(field, x, y, dx, dy, x_off=0.0, y_off=0.0):
  x_f = (x + x_off) / dx
  y_f = (y + y_off) / dy

  i = int(np.floor(x_f))
  j = int(np.floor(y_f))

  a = x_f - i
  b = y_f - j
  nx, ny = field.shape

  i0 = max(0, min(i, nx - 1))
  j0 = max(0, min(j, ny - 1))
  i1 = max(0, min(i + 1, nx - 1))
  j1 = max(0, min(j + 1, ny - 1))

  v00 = field[i0, j0]
  v10 = field[i1, j0]
  v01 = field[i0, j1]
  v11 = field[i1, j1]

  return ((1 - a) * (1 - b) * v00 +
          a * (1 - b) * v10 +
          (1 - a) * b * v01 +
          a * b * v11)

@jit(nopython=True)
def build_laplacian_triplets(N, dx, dy):
  max_entries = N * N * 5  # max 5 entries per cell
  row = np.zeros(max_entries, dtype=np.int32)
  col = np.zeros(max_entries, dtype=np.int32)
  data = np.zeros(max_entries)
  
  count = 0
  for i in range(N):
    for j in range(N):
      idx = i * N + j
      
      row[count] = idx
      col[count] = idx
      data[count] = -2/dx**2 - 2/dy**2
      count += 1
      
      if i > 0:
          row[count] = idx
          col[count] = (i-1)*N + j
          data[count] = 1/dx**2
          count += 1
      if i < N-1:
          row[count] = idx
          col[count] = (i+1)*N + j
          data[count] = 1/dx**2
          count += 1
      if j > 0:
          row[count] = idx
          col[count] = i*N + (j-1)
          data[count] = 1/dy**2
          count += 1
      if j < N-1:
          row[count] = idx
          col[count] = i*N + (j+1)
          data[count] = 1/dy**2
          count += 1
  
  return row[:count], col[:count], data[:count]

def build_laplacian_matrix(N, dx, dy):
    row, col, data = build_laplacian_triplets(N, dx, dy)
    return csr_matrix((data, (row, col)), shape=(N*N, N*N))


@jit(nopython=True)
def divergence(u, v, dx, dy):
  N = u.shape[1]
  div = np.zeros((N, N))

  for i in range(N):
    for j in range(N):
      div[i, j] = (u[i + 1, j] - u[i, j]) / dx + (v[i, j + 1] - v[i, j]) / dy

  return div


class FluidSim:
  def __init__(self, N: int, width: float, height: float):
    self.N = N

    # MAC Grid

    '''
    -----v01----
     |         |
    u00  P00  u10
     |         |
    -----v00----
    '''
    self.u = np.random.randn(N + 1, N)
    self.v = np.random.randn(N, N + 1)
    self.p = np.zeros((N, N))

    self.u_prev = np.random.randn(N + 1, N)
    self.v_prev = np.random.randn(N, N + 1)

    self.dx = width / N
    self.dy = height / N

    umax = 50.0
    self.dt = 5 * self.dx / umax

    self.t = 0.0

    self.log = dict()
    self.log[self.t] = f'{self.u=}\n{self.u_prev=}\n{self.v=}\n{self.v_prev=}'

  def swap(self):
    self.u, self.u_prev = self.u_prev, self.u
    self.v, self.v_prev = self.v_prev, self.v

  def get_u(self, i, j):
    return (self.u[i, j] + self.u[i + 1, j]) * 0.5

  def get_v(self, i, j):
    return (self.v[i, j] + self.v[i, j + 1]) * 0.5

  '''
  Chapter 3.
  Advection equation: Dq/Dt = 0
  => q_(n+1) = advect(u, dt, q_n)

  Forward Euler.
  (q[i]_(n+1) - q[i]_n) / dt + u * (q[i+1]_n - q[i-1]_n) / (2 * dx) +
  v * (q[i+1]_n - q[i-1]_n) / (2 * dy) = 0
  But, this is unconditionally unstable no matter how small dt is!
  reason: eigenvalues of the Jacobian generated by the central difference
  are pure imaginary, thus always outside the region of stability.

  solution? semi lagrangian approach.
  which is unconditionally stable. no matter how large dt is!
  q[G]_(n+1) = interpolate(q_n, x[G] - dt * u[G])
  x[P] = x[i] - dt * u[i]
  let x[P] lies in (x[j], x[j+1])
  let a = (x[P] - x[j]) / dx
  q[i]_(n+1) = (1 - a) * q[j]_n + a * q[j+1]_n
  '''

  def advect_u(self):
    dx = self.dx
    dy = self.dy
    dt = self.dt
    N = self.N

    for i in range(N + 1):
      for j in range(N):
        x_i = dx * i
        y_i = dy * (j + 0.5)

        u_here = bilerp(self.u_prev, x_i, y_i, dx, dy)
        v_here = bilerp(self.v_prev, x_i, y_i, dx, dy, x_off=-0.5 * dx)

        x_P = x_i - dt * u_here
        y_P = y_i - dt * v_here

        self.u[i, j] = bilerp(self.u_prev, x_P, y_P, dx, dy, y_off=-0.5 * dy)

  def advect_v(self):
    dx = self.dx
    dy = self.dy
    dt = self.dt
    N = self.N

    for i in range(N):
      for j in range(N + 1):
        x_i = dx * (i + 0.5)
        y_i = dy * j

        u_here = bilerp(self.u_prev, x_i, y_i, dx, dy, y_off=-0.5 * dy)
        v_here = bilerp(self.v_prev, x_i, y_i, dx, dy)

        x_P = x_i - dt * u_here
        y_P = y_i - dt * v_here

        self.v[i, j] = bilerp(self.v_prev, x_P, y_P, dx, dy, x_off=-0.5 * dx)

  def dampen(self, factor=0.8):
    u = self.u
    v = self.v
    p = self.p

    u *= factor
    v *= factor
    p *= factor    

  '''
    the project(∆t, u) routine does the following:
    • Calculate the divergence d (the right-hand side) with modifications at solid wall boundaries.
    • Set the entries of A (stored in Adiag etc.).
    • Construct the MIC(0) preconditioner.
    • Solve Ap = d with MICCG(0), i.e. the PCG algorithm with MIC(0) as preconditioner.
    • Compute the new velocities u_(n+1) according to the pressure gradient update to u.
  '''

  def project(self):
    u = self.u
    v = self.v
    p = self.p
    dx = self.dx
    dy = self.dy
    dt = self.dt
    N = self.N

    div = divergence(u, v, dx, dy)

    if not hasattr(self, '_A_matrix'):
      self._A_matrix = build_laplacian_matrix(N, dx, dy)
      self._M = spilu(self._A_matrix)
      self._M_op = LinearOperator(self._A_matrix.shape, self._M.solve)
    
    rhs = -div.flatten()
    p_flat, info = cg(self._A_matrix, rhs, M=self._M_op, rtol=1e-6, maxiter=100)
    p = p_flat.reshape((N, N))
    self.p = p

    for i in range(1, N):
      for j in range(N):
        u[i, j] -= dt * (p[i, j] - p[i-1, j]) / dx

    for i in range(N):
      for j in range(1, N):
        v[i, j] -= dt * (p[i, j] - p[i, j-1]) / dy    


  def boundary(self):
    N = self.N
    u = self.u
    v = self.v

    for k in range(N + 1):
      u[k, 0] = 0
      u[k, N - 1] = 0
      v[0, k] = 0
      v[N - 1, k] = 0

  def add_force(self, row_idx, col_idx, fx, fy, radius=3):
    radius_sq = radius**2

    for i in range(max(0, row_idx - radius), min(self.N + 1, row_idx + radius + 1)):
      for j in range(max(0, col_idx - radius), min(self.N, col_idx + radius + 1)):
        u_row = i
        u_col = j + 0.5
        dist_sq = (u_row - row_idx)**2 + (u_col - col_idx)**2
        if dist_sq < radius_sq:
          strength = 1 - np.sqrt(dist_sq) / radius
          self.u[i, j] += fx * strength * self.dt

    for i in range(max(0, row_idx - radius), min(self.N, row_idx + radius + 1)):
      for j in range(max(0, col_idx - radius), min(self.N + 1, col_idx + radius + 1)):
        v_row = i + 0.5
        v_col = j
        dist_sq = (v_row - row_idx)**2 + (v_col - col_idx)**2
        if dist_sq < radius_sq:
          strength = 1 - np.sqrt(dist_sq) / radius
          self.v[i, j] += fy * strength * self.dt

  def dump_log(self):
    with open('log.txt', 'w') as f:
      for key, value in self.log.items():
        f.write(f'{key}:\n{value}\n')
